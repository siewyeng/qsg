;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Singlish
;;; created at:
;;;     Thu Mar 19 01:28:10 UTC 2020
;;; based on Matrix customization system version of:
;;;     Fri May 10 21:15:28 UTC 2019
;;;
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

head :+ [ PRON bool,
    AUX bool,
    PRD bool,
    FORM form ].

noun :+ [ CASE case ].

png :+ [ PER person,
    NUM number ].

basic-head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

; For the analysis of inverted yes-no questions, we add the feature INV.

verb :+ [ INV bool ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Case

case := *top*.
nom := case.  ; nominative
acc := case.  ; accusative

;;; Person

person := *top*.
1st := person.
2nd := person.
3rd := person.

;;; Number

number := *top*.
singular := number.
plural := number.

;;; Form

form := *top*.
nonfinite := form.
finite := form.
base := nonfinite.
prp := nonfinite
"""
participle -ed, -ing
"""
.

;;; Tense

nonpast := tense.
past := tense.

;;; Aspect

perfect := aspect.
experiential := aspect.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Nouns

noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < #spr &
                                 [ LOCAL.CAT.HEAD det ] >,
                           COMPS < >,
                           SUBJ < >,
                           SPEC < > ],
    ARG-ST < #spr > ].

no-spr-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

; Nouns which cannot take specifiers mark their SPR requirement
; as OPT +.  Making the non-head daughter OPT - in this rule
; keeps such nouns out.
; 
; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM.OPT - ].

nom_pronoun-noun-lex := pronoun-noun-lex & no-spr-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON +,
                            CASE nom ] ].

acc_pronoun-noun-lex := pronoun-noun-lex & no-spr-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON +,
                            CASE acc ] ].

common_noun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

1sg_nom-noun-lex := nom_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ PER 1st,
                                         NUM singular ] ] ].

3sg_nom-noun-lex := nom_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ PER 3rd,
                                         NUM singular ] ] ].

3pl_nom-noun-lex := nom_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM plural,
                                         PER 3rd ] ] ].

1pl_nom-noun-lex := nom_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM plural,
                                         PER 1st ] ] ].

pronoun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON + ].

it-noun-lex := pronoun-noun-lex & no-spr-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM singular,
                                         PER 3rd ] ] ].

you-noun-lex := pronoun-noun-lex & no-spr-noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 2nd ].

1sg_acc-noun-lex := acc_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM singular,
                                         PER 1st ] ] ].

1pl_acc-noun-lex := acc_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM plural,
                                         PER 1st ] ] ].

3sg_acc-noun-lex := acc_pronoun-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRON +,
                   CONT.HOOK.INDEX.PNG [ NUM singular,
                                         PER 3rd ] ] ].

;;; Verbs

; verb-lex is HC-LIGHT - to allow us to pick out
; 
;   lexical Vs for V-level attachment of negative adverbs.
; 
; All verbs start off as not inverted.

verb-lex := non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT [ HC-LIGHT -,
                       HEAD verb &
                            [ INV - ] ] ].

main-verb-lex := verb-lex & basic-verb-lex & fin-or-nonfin-rule-dtr &
  [ SYNSEM.LOCAL [ CAT [ HEAD.AUX -,
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < #subj > ] ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT cat-sat &
                               [ VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg ] ] ].

aux-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.AUX + ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST.FIRST.LOCAL.CAT.HEAD noun ].

transitive-verb-lex := main-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT cat-sat &
                         [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun ] ] > ].

nom-intransitive-verb-lex := intransitive-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE nom ] ].

nom-acc-transitive-verb-lex := transitive-verb-lex &
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE nom ] ],
             [ LOCAL.CAT.HEAD noun &
                              [ CASE acc ] ] > ].

transitive_verb-verb-lex := nom-acc-transitive-verb-lex.

intransitive_verb-verb-lex := intransitive-verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM form ].

;;; Auxiliaries

subj-raise-aux := aux-lex & trans-first-arg-raising-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
                             SPEC < >,
                             COMPS < #comps >,
                             SUBJ < #subj > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT [ HEAD noun &
                                  [ CASE #case ],
                             VAL [ SUBJ < >,
                                   SPR < >,
                                   SPEC < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #xarg ] ],
             #comps &
             [ LOCAL.CAT [ HEAD verb &
                                [ AUX - ],
                           VAL [ COMPS < >,
                                 SPR < >,
                                 SPEC < >,
                                 SUBJ < unexpressed &
                                        [ LOCAL.CAT.HEAD.CASE #case ] > ] ] ] > ].

subj-raise-aux-with-pred := subj-raise-aux & norm-sem-lex-item & trans-first-arg-raising-lex-item-1.

subj-raise-aux-no-pred := subj-raise-aux & trans-first-arg-raising-lex-item-2 &
			  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM prp].


probability_aux-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM base ].

can-aux-lex := subj-raise-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM base ].

;;; Copulas

cop-lex := basic-verb-lex-super & trans-first-arg-raising-lex-item-2 & non-mod-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #xarg,
                                              CAT cat-sat &
                                                  [ VAL [ SPR < >,
                                                          COMPS < > ],
                                                    HEAD noun ] ] ] >,
                             COMPS < [ LOCAL.CAT cat-sat &
                                                 [ HEAD.PRD +,
                                                   VAL [ SUBJ < >,
                                                         COMPS < > ] ] ] >,
                             SPR < >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ] ].

; Copula type taking adjectival complements.
; Need to define more for additional complement types.

adj-comp-copula-verb-lex := cop-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD adj ].

be-cop-lex := adj-comp-copula-verb-lex.

is-cop-lex := be-cop-lex &
    [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG [ NUM singular,
					 PER 3rd ] ].
;;; Adjectives

adj-lex := basic-intersective-adjective-lex.

adj1-adj-lex := attr-adj-lex &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD -,
                       VAL.SUBJ < >,
                       HEAD.PRD + ] ].

; Basic attributive adjective definition

attr-adj-lex := adj-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun,
                                              VAL.SPR cons ] ] > ].

;;; Complementizers

; We treat question particles as complementizers.
; Here is the lexical type for complementizers.

complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comp > ] ],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].

; Subtype for question particles. Constrains SF to ques.

qpart-lex-item := complementizer-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT.VAL.COMPS.FIRST.LOCAL.CAT [ MC +,
                                                   HEAD.FORM finite ] ] ].

;;; Others

;;; Determiners
;;; SPEC is non-empty, and already specified by basic-determiner-lex.

determiner-lex := basic-determiner-lex & norm-zero-arg & non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           COMPS < >,
                           SUBJ < > ] ].

definite-determiner-lex := determiner-lex & no-icons-lex-item.

plural-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

singular-determiner-lex := determiner-lex & no-icons-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

; Type for negative adverbs.
; 
; This adverb should go through a specialized phrase structure rule
;                           included with this grammar.

neg-adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       POSTHEAD -,
                       HEAD.MOD < [ LOCAL.CAT [ HEAD verb,
                                                VAL [ SUBJ cons,
                                                      COMPS null ] ] ] > ] ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

;;; Intermediate rule types

fin-or-nonfin-rule-dtr := word-or-lexrule.

;;; Lexical rule types

number-lex-rule-super := add-only-no-ccont-rule &
  [ DTR common_noun-noun-lex ].

plural-lex-rule := infl-lex-rule & number-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

singular-lex-rule := const-lex-rule & number-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

fin-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ DTR fin-or-nonfin-rule-dtr ].


3sg-lex-rule := fin-lex-rule-super &
""" 
19/3/2020 

added in 'HEAD.FORM finite' to the 3sg-lex-rule so that when it is non finite (eg. with Vaux), the verb will not undergo this rule 
""" 
  [ SYNSEM.LOCAL.CAT [HEAD.FORM finite,
                      VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM singular,
                                                                PER 3rd ] ]].

question-lex-rule := add-only-no-ccont-rule &
  [ DTR probability_aux-aux-lex,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques ].

nonfin-lex-rule-super := add-only-no-ccont-rule &
  [ DTR fin-or-nonfin-rule-dtr ].

base-lex-rule := const-lex-rule & nonfin-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM base ].

prp-lex-rule := infl-lex-rule & nonfin-lex-rule-super &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.E.ASPECT experiential,
                   CAT.HEAD.FORM prp ] ].

; Rule for inverted subject verb order in questions.
; The incompatible SUBJ values on SYNSEM and DTR are
; what keeps this one from spinning.


subj-v-inv-lrule := cat-change-only-lex-rule & same-hc-light-lex-rule & same-posthead-lex-rule & constant-lex-rule &
""" 

19/3/2020 

added in #mod in the HEAD and DTR values to ensure that they have the same MOD value 

probem solved: when the aux is able to modify anything after undergoing the subj-inv 

""" 
  [ SYNSEM [ LKEYS #lkeys,
             LOCAL.CAT [ VAL [ COMPS < #subj . #comps >,
                               SUBJ < >,
                               SPR #spr,
                               SPEC #spec ],
                         MC na,
                         HEAD verb &
                              [ INV +,
				MOD #mod,
                                FORM #form ] ] ],
    DTR.SYNSEM [ LKEYS #lkeys,
                 LOCAL.CAT [ VAL [ SUBJ < #subj >,
                                   COMPS #comps,
                                   SPR #spr,
                                   SPEC #spec ],
                             HEAD verb &
                                  [ AUX +,
				    MOD #mod,
                                    FORM #form ] ] ] ].

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

; The head of head-comp-phrase can't be: ['comp']

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD +nvjrpdmo ].

subj-head-phrase := decl-head-subj-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >].
  [ SYNSEM [ LKEYS #lkeys,
             LOCAL.CAT [ VAL [ COMPS < #subj . #comps >,
                               SUBJ < >,	
                               SPR #spr,
                               SPEC #spec ],
                         MC na,
                         HEAD verb &
                              [ INV +,
				MOD #mod,
                                FORM #form ] ] ],
    DTR.SYNSEM [ LKEYS #lkeys,
                 LOCAL.CAT [ VAL [ SUBJ < #subj >,
                                   COMPS #comps,
                                   SPR #spr,
                                   SPEC #spec ],
                             HEAD verb &
                                  [ AUX +,
				    MOD #mod,
                                    FORM #form ] ] ] ].

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

; comp-head-phrase requires things that are [ HEAD comp ].

comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD comp ].

; This rule takes [MC na] inverted phrases and licensesthem as main clauses with question semantics.
; 

int-cl := interrogative-clause & head-only &
  [ SYNSEM.LOCAL.CAT [ HEAD.INV +,
                       VAL #val,
                       MC + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC na,
                                VAL #val &
                                    [ SUBJ < >,
                                      COMPS < > ] ],
    C-CONT.HOOK.INDEX.SF ques ].

;;;;;;;;;;;;;;;;;;
;;; Coordination
;;;;;;;;;;;;;;;;;;

;;; Coordination Strategy 1

n1-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

n1-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

n1-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 1

np1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 1

vp1-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

vp1-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 1

s1-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

s1-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 2

n2-top-coord-rule := basic-n-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

n2-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

;;; Coordination Strategy 2

np2-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

np2-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

;;; Coordination Strategy 2

s2-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

s2-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

noun+det-lex-item := norm-hook-lex-item &non-mod-lex-item &
  [ SYNSEM [LOCAL [CAT [ HEAD noun,
			 VAL [ SPR < >,   
   			       COMPS < >,
			       SUBJ < >,
			       SPEC < > ]],
		   CONT [RELS <! relation &
		               [LBL #nh, ARG0 #s ],
			       quant-relation & #det &
			       [ARG0 #s, RSTR #h ]!>,
			HCONS <! qeq & [ HARG #h,
					 LARG #nh ] !> ]],
 	    LKEYS [ KEYREL relation,
		    ALTKEYREL #det ]]].

sg_n+det-lex := noun+det-lex-item &
    [SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM singular ].

pl_n+det-lex := noun+det-lex-item &
    [SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].
